<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Concept Note</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css"></link>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
    <style>
@import url('https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;500;600&family=Roboto:wght@300;400;500&display=swap');

@page {
    size: A4;
    margin: 0;
}
     
body {
    background-color: #f8f9fa;
    margin: 0;
    font-family: Arial, sans-serif;
    display: flex;
    margin: 50px;
    flex-direction: column;
    gap: 20px;
}
.search-box {
    margin-bottom: 20px;
}
.search-box input {
    width: 100%;
    padding: 8px 12px;
    font-size: 1em;
    border: 1px solid #ccc;
    border-radius: 6px;
}
.schedule-list {
  display: flex;
  flex-direction: column;
  gap: 15px;
}
.schedule-item {
  border: 1px solid #ddd;
  border-radius: 10px;
  padding: 12px 16px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.05);
  background: #fff;
}
.schedule-header {
  display: flex;
  justify-content: space-between;
  font-weight: bold;
  margin-bottom: 6px;
}
.schedule-header-left {
  color: #333;
}
.schedule-header-right {
  color: #666;
  font-size: 0.9em;
}
.schedule-concept,
.schedule-topic {
  margin: 4px 0;
  color: #444;
}
.schedule-topic {
  font-style: italic;
  color: #555;
}
    /* Container styling */

.container {
    display: flex;
    margin: 30px;
    flex-direction: column;
    align-items: left;
}
.conceptnotehead {
    display: flex;
    margin: 30px;
    flex-direction: column;
    align-items: center;
}
table {
  width: 100%;
  border-collapse: separate;
  border-spacing: 0;
  border-radius: 12px;
  overflow: hidden;
  box-shadow: 0 4px 12px rgba(0,0,0,0.1);
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}

/* Table header */
th {
  background: #333;
  color: white;
  font-weight: 600;
  text-align: center;
  padding: 12px 15px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

/* Table rows */
td {
  padding: 8px 10px;
  text-align: center;
  color: #333;
}

/* Alternating row colors */
tr:nth-child(even) td {
  background-color: #f9f9f9;
}

/* Hover effect */
tr:hover td {
  background-color: #e0f2f1;
  transition: background-color 0.3s ease;
}

/* Optional table title */
h1 {
    text-align: center;
}


h3 {
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  text-align: center;
  color: #333;
  margin: 25px 0 10px 0;
  font-size: 1.3em;
}
.toggle-bar {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  background: #2c3e50;
  padding: 10px;
  display: flex;
  justify-content: center;
  gap: 10px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.2);
  z-index: 1000;
}

/* Button styling */
.toggle-btn {
  padding: 10px 20px;
  font-size: 15px;
  border: none;
  border-radius: 6px;
  background: #ecf0f1;
  color: #2c3e50;
  cursor: pointer;
  transition: all 0.3s ease;
}

.toggle-btn:hover {
  background: #bdc3c7;
}

/* Active button */
.toggle-btn.active {
  background: #3498db;
  color: #fff;
  font-weight: 600;
  box-shadow: 0 2px 6px rgba(0,0,0,0.2) inset;
}

/* Wrap tables in a responsive container */
.table-container {
  width: 100%;
  overflow-x: auto;   /* horizontal scroll */
  -webkit-overflow-scrolling: touch; /* smooth scroll on iOS */
}

/* Make sure table is at least full width */
.table-container table {
  width: 100%;
  border-collapse: collapse;
}
    </style>
</head>
<body>
<div class="toggle-bar">
    <button class="toggle-btn" id="showconceptbutton">Concept note</button>
    <button class="toggle-btn" id="showschedulebutton">Schedule</button>
</div>


<div id="conceptnotepage" style="display: block;">
    <div class="conceptnotehead">
        <h1>PROGRAM CONCEPTS AND TOPICS WITH RUBRICS</h1>
        <!-- Search box -->
            <div class="search-box">
                <input type="text" id="conceptsearchInput" placeholder="Search by code, program, category, or topic...">
            </div>
        <div id="scheduleList" class="schedule-list"></div>
    </div>
    
</div>

<div id="schedulepage" style="display: none;">
    <div class="container">
        <h1 id="main-heading">SCHEDULE</h1>
            <div class="search-box">
                <input type="text" id="schedulesearchInput" placeholder="Search by code, program, category, or topic...">
            </div>
        <div id="schedule"></div>
    </div>
</div>
<script>

const conceptbutton = document.getElementById("showconceptbutton");
const schedulebutton = document.getElementById("showschedulebutton");
const conceptnotepage = document.getElementById("conceptnotepage");
const schedulepage = document.getElementById("schedulepage");

  // On button click, set display to block
  conceptbutton.addEventListener("click", () => {
    conceptnotepage.style.display = "block";
    schedulepage.style.display = "none";
  });

  schedulebutton.addEventListener("click", () => {
    conceptnotepage.style.display = "none";
    schedulepage.style.display = "block";
  });

        const SHEET_ID = "1Q6e6JO2uDz5m5PzkSq8-lzJWMgh0eWi1SKMLZfwzgNE";
        const makeGvizUrl = (sheetName) =>
            `https://docs.google.com/spreadsheets/d/${SHEET_ID}/gviz/tq?sheet=${encodeURIComponent('PROGRAMS')}&tqx=out:json`;
        function loadGvizSheet1(sheetName) {
            return new Promise((resolve, reject) => {
                window.google = window.google || {};
                window.google.visualization = window.google.visualization || {};
                window.google.visualization.Query = window.google.visualization.Query || {};
                const originalSetResponse = window.google.visualization.Query.setResponse;
                const cleanup = () => {
                    window.google.visualization.Query.setResponse = originalSetResponse || function () {};
                };
                const timeout = setTimeout(() => {
                    cleanup();
                    reject(new Error(`Timeout loading sheet: ${sheetName}`));
                }, 15000);
                window.google.visualization.Query.setResponse = function (response) {
                    try {
                        clearTimeout(timeout);
                        cleanup();
                        if (!response || !response.table) {
                            throw new Error("No table in response");
                        }
                        resolve(response);
                    } catch (err) {
                        clearTimeout(timeout);
                        cleanup();
                        reject(err);
                    }
                };
                const script = document.createElement("script");
                script.src = makeGvizUrl(sheetName);
                script.async = true;
                script.onerror = () => {
                    clearTimeout(timeout);
                    cleanup();
                    reject(new Error(`Failed to load sheet script for "${sheetName}"`));
                };
                document.body.appendChild(script);
            });
        }
        function parseJavaScriptDate(dateString) {
            if (typeof dateString !== 'string') return null;
            
            // Try to extract date components from various formats
            const dateMatch = dateString.match(/Date\(([^)]+)\)/);
            if (dateMatch) {
                const parts = dateMatch[1].split(',');
                if (parts.length >= 3) {
                    const year = parseInt(parts[0]);
                    const month = parseInt(parts[1]); // 0-11
                    const day = parseInt(parts[2]);
                    return new Date(day, month, year);
                }
            }
            
            // Fallback: try direct parsing
            return new Date(dateString);
        }



        function parseJavaScriptDateTime(dateTimeString) {
            if (typeof dateTimeString !== 'string') return null;
            
            // Try to extract date and time components
            const dateTimeMatch = dateTimeString.match(/Date\(([^)]+)\)/);
            if (dateTimeMatch) {
                const parts = dateTimeMatch[1].split(',');
                if (parts.length >= 6) {
                    const year = parseInt(parts[0]);
                    const month = parseInt(parts[1]); // 0-11
                    const day = parseInt(parts[2]);
                    const hour = parseInt(parts[3]);
                    const minute = parseInt(parts[4]);
                    const second = parseInt(parts[5]);
                    return new Date(year, month, day, hour, minute, second);
                }
            }
            
            // Fallback: try direct parsing
            return new Date(dateTimeString);
        }



        function formatDate(dateObj) {
            if (!(dateObj instanceof Date) || isNaN(dateObj.getTime())) return '';
            return dateObj.toLocaleDateString('en-GB', { day: "2-digit", month: "2-digit", year: "2-digit" }); // DD/MM/YY format
        }


        function formatTime(timeObj) {
            if (!(timeObj instanceof Date) || isNaN(timeObj.getTime())) return '';
            return timeObj.toLocaleTimeString('en-US', { 
                hour: 'numeric', 
                minute: '2-digit',
                hour12: true // AM/PM format
            });
        }



        function parseScheduleResponse1(response) {
            const headers = (response.table.cols || []).map(c => (c.label || '').toLowerCase());
            const rawRows = response.table.rows || [];
            return rawRows.map(r => {
                const cells = r.c || [];
                const get = key => {
                    const idx = headers.indexOf(key);
                    if (idx === -1) return '';
                    const cell = cells[idx];
                    return cell ? (cell.v ?? '') : '';
                };
                
                let dateValue = get('date');
                let startValue = get('start');
                let endValue = get('end');
                
                // Parse date values
                if (dateValue) {
                    dateValue = parseJavaScriptDate(dateValue);
                }
                
                if (startValue) {
                    startValue = parseJavaScriptDateTime(startValue);
                }
                
                if (endValue) {
                    endValue = parseJavaScriptDateTime(endValue);
                }
                
                return {
                    code: get('code'),
                    program: get('name'),
                    category: get('category'),
                    mode: get('mode'),
                    concept: get('concept'),
                    topic: get('topic'),
                    rubrics: get('rubrics'),
                };
            }); // Only include entries with a judge
        }


document.addEventListener('DOMContentLoaded', async () => {
    try {
        const scheduleResponse = await loadGvizSheet1('PROGRAMS');
        const scheduleData = parseScheduleResponse1(scheduleResponse);
      
const list = document.getElementById("scheduleList");
const searchInput = document.getElementById("conceptsearchInput");
                
function renderList(data) {
      list.innerHTML = "";
      data.forEach(item => {
        const html = `
          <div class="schedule-item">
            <div class="schedule-header">
              <div class="schedule-header-left">${item.code} - ${item.program}</div>
              <div class="schedule-header-right">${item.category} | ${item.mode}</div>
            </div>
            <div class="schedule-concept">${item.concept}</div>
            <h4>Topic</h4>
            <div class="schedule-topic">${item.topic}</div>
            <h4>Rubrics: ${item.rubrics}</h4>
          </div>
        `;
        list.insertAdjacentHTML("beforeend", html);
      });
    }

    // Initial render
    renderList(scheduleData);

    // Filter on input
    searchInput.addEventListener("input", () => {
      const query = searchInput.value.toLowerCase();
      const filtered = scheduleData.filter(item =>
        item.code.toLowerCase().includes(query) ||
        item.program.toLowerCase().includes(query) ||
        item.category.toLowerCase().includes(query) ||
        item.mode.toLowerCase().includes(query) ||
        item.concept.toLowerCase().includes(query) ||
        item.topic.toLowerCase().includes(query)
      );
      renderList(filtered);
    });
              
            // error handler
            } catch (error) {
                console.error('Error loading schedule data:', error);
                alert('Failed to load schedule data. Please check the sheet ID and sharing settings.');
            }
        });

        const SHEET_ID2 = "1Q6e6JO2uDz5m5PzkSq8-lzJWMgh0eWi1SKMLZfwzgNE";
        const makeGvizUrl2 = (sheetName) =>
            `https://docs.google.com/spreadsheets/d/${SHEET_ID2}/gviz/tq?sheet=${encodeURIComponent('SCHEDULE')}&tqx=out:json`;
        function loadGvizSheet2(sheetName) {
            return new Promise((resolve, reject) => {
                window.google = window.google || {};
                window.google.visualization = window.google.visualization || {};
                window.google.visualization.Query = window.google.visualization.Query || {};
                const originalSetResponse = window.google.visualization.Query.setResponse;
                const cleanup = () => {
                    window.google.visualization.Query.setResponse = originalSetResponse || function () {};
                };
                const timeout = setTimeout(() => {
                    cleanup();
                    reject(new Error(`Timeout loading sheet: ${sheetName}`));
                }, 15000);
                window.google.visualization.Query.setResponse = function (response) {
                    try {
                        clearTimeout(timeout);
                        cleanup();
                        if (!response || !response.table) {
                            throw new Error("No table in response");
                        }
                        resolve(response);
                    } catch (err) {
                        clearTimeout(timeout);
                        cleanup();
                        reject(err);
                    }
                };
                const script = document.createElement("script");
                script.src = makeGvizUrl2(sheetName);
                script.async = true;
                script.onerror = () => {
                    clearTimeout(timeout);
                    cleanup();
                    reject(new Error(`Failed to load sheet script for "${sheetName}"`));
                };
                document.body.appendChild(script);
            });
        }
        function parseJavaScriptDate(dateString) {
            if (typeof dateString !== 'string') return null;
            
            // Try to extract date components from various formats
            const dateMatch = dateString.match(/Date\(([^)]+)\)/);
            if (dateMatch) {
                const parts = dateMatch[1].split(',');
                if (parts.length >= 3) {
                    const year = parseInt(parts[0]);
                    const month = parseInt(parts[1]); // 0-11
                    const day = parseInt(parts[2]);
                    return new Date(day, month, year);
                }
            }
            
            // Fallback: try direct parsing
            return new Date(dateString);
        }



        function parseJavaScriptDateTime(dateTimeString) {
            if (typeof dateTimeString !== 'string') return null;
            
            // Try to extract date and time components
            const dateTimeMatch = dateTimeString.match(/Date\(([^)]+)\)/);
            if (dateTimeMatch) {
                const parts = dateTimeMatch[1].split(',');
                if (parts.length >= 6) {
                    const year = parseInt(parts[0]);
                    const month = parseInt(parts[1]); // 0-11
                    const day = parseInt(parts[2]);
                    const hour = parseInt(parts[3]);
                    const minute = parseInt(parts[4]);
                    const second = parseInt(parts[5]);
                    return new Date(year, month, day, hour, minute, second);
                }
            }
            
            // Fallback: try direct parsing
            return new Date(dateTimeString);
        }


        function formatTime(timeObj) {
            if (!(timeObj instanceof Date) || isNaN(timeObj.getTime())) return '';
            return timeObj.toLocaleTimeString('en-US', { 
                hour: 'numeric', 
                minute: '2-digit',
                hour12: true // AM/PM format
            });
        }

function formatSheetDate(sheetDate) {
  // If already a string in proper format, return it
  if (typeof sheetDate === "string") return sheetDate;

  // Sheet dates are counted from 30 Dec 1899
  const excelEpoch = new Date(1899, 11, 30); // Dec 30, 1899

  // Convert numeric value to milliseconds
  const jsDate = new Date(excelEpoch.getTime() + sheetDate * 24 * 60 * 60 * 1000);

  // Extract day, month, year
  const day = String(jsDate.getDate()).padStart(2, "0");
  const month = String(jsDate.getMonth() + 1).padStart(2, "0"); // months are 0-based
  const year = jsDate.getFullYear();

  return `${day}-${month}-${year}`;
}


function formatSheetDateVerbose(value) {
  let dateObj;

  if (value instanceof Date) {
    dateObj = value; // already a Date object
  } 
  else if (typeof value === "string") {
    // If string is like "Date(2025,8,28)"
    const match = value.match(/Date\((\d+),\s*(\d+),\s*(\d+)\)/);
    if (match) {
      const year = parseInt(match[1], 10);
      const month = parseInt(match[2], 10); // 0-based
      const day = parseInt(match[3], 10);
      dateObj = new Date(year, month, day);
    } else {
      // fallback: try parsing as normal string
      dateObj = new Date(value);
    }
  } 
  else {
    return "Invalid date";
  }

  if (isNaN(dateObj.getTime())) return "Invalid date";

  const year = dateObj.getFullYear();
  const day = dateObj.getDate();
  const monthNames = [
    "January", "February", "March", "April", "May", "June",
    "July", "August", "September", "October", "November", "December"
  ];
  const month = monthNames[dateObj.getMonth()];

  return `${year} ${month} ${day}`;
}


        function parseScheduleResponse2(response) {
            const headers = (response.table.cols || []).map(c => (c.label || '').toLowerCase());
            const rawRows = response.table.rows || [];
            
            return rawRows.map(r => {
                const cells = r.c || [];
                const get = key => {
                    const idx = headers.indexOf(key);
                    if (idx === -1) return '';
                    const cell = cells[idx];
                    return cell ? (cell.v ?? '') : '';
                };
                
                let dateValue = get('date_out');
                let startValue = get('start');
                let endValue = get('end');
                
                // Parse date values
                if (dateValue) {
                    // dateValue = parseJavaScriptDate(dateValue);
                    dateValue = formatSheetDate(dateValue);
                }
                
                if (startValue) {
                    startValue = parseJavaScriptDateTime(startValue);
                }
                
                if (endValue) {
                    endValue = parseJavaScriptDateTime(endValue);
                }
                
                return {
                    date: formatSheetDateVerbose(dateValue),
                    day: get('day'),
                    start: formatTime(startValue),
                    end: formatTime(endValue),
                    code: get('code'),
                    program: get('program'),
                    category: get('category'),
                    venue: get('venue'),
                    //judge1: get('judge1'),
                    //judge2: get('judge2'),
                    //judge3: get('judge3')
                };
            }).filter(entry => entry.date); // Only include entries with a judge
        }


function printSheet(id) {
  let content = document.getElementById(id);

  // Open new print window
  let printWindow = window.open('', '', 'height=842,width=595'); // A4 size

  // Copy stylesheets and inline styles
  let styles = Array.from(document.querySelectorAll('style, link[rel="stylesheet"]'))
    .map(node => node.outerHTML)
    .join('');

  // Write the document with styles + content
  printWindow.document.write(`
    <html>
      <head>
        <title>Print</title>
        ${styles}
      </head>
      <body>
        ${content.outerHTML}
      </body>
    </html>
  `);

  printWindow.document.close();

  // Wait until content is fully loaded before printing
  printWindow.onload = function () {
    printWindow.focus();
    printWindow.print();
    // printWindow.close(); // optional: close after printing
  };
}


        document.addEventListener('DOMContentLoaded', async () => {
            try {
                const scheduleResponse = await loadGvizSheet2('SCHEDULE');
                const scheduleData = parseScheduleResponse2(scheduleResponse);
                const schedulesearchInput = document.getElementById('schedulesearchInput');
                
                window.dates = {};
                scheduleData.forEach(entry => {
                    const dateNum = entry.date;
                    if (!dates[dateNum]) {
                        dates[dateNum] = [];
                    }
                    dates[dateNum].push(entry);
                });
                // console.log(window.dates);
                // console.log(Object.keys(window.dates).length);
            
                const container = document.getElementById('schedule');

                const table = document.createElement('table');
                    table.className = 'schedule-table';
                    
                    const thead = document.createElement('thead');
                    const headerRow = document.createElement('tr');
                    ['Date', 'Day', 'Start Time', 'End Time', 'Code', 'Program', 'Category', 'Venue'].forEach(col => {
                        const th = document.createElement('th');
                        th.textContent = col;
                        headerRow.appendChild(th);
                    });
                    thead.appendChild(headerRow);



    for (const [dateKey, rows] of Object.entries(dates)) {
      if (rows.length === 0) continue;

      // Table title
      const title = document.createElement("h3");
      title.textContent = `Date: ${dateKey}`;
      container.appendChild(title);

      const table = document.createElement("table");

      // Table header (skip 'date' column)
      const headerRow = document.createElement("tr");
      Object.keys(rows[0])
        .filter(key => key !== "date")
        .forEach(key => {
          const th = document.createElement("th");
          th.textContent = key;
          headerRow.appendChild(th);
        });
      table.appendChild(headerRow);

      // Table rows
      rows.forEach(obj => {
        const tr = document.createElement("tr");
        Object.entries(obj)
          .filter(([key]) => key !== "date")
          .forEach(([key, val]) => {
            const td = document.createElement("td");
            td.textContent = val;
            tr.appendChild(td);
          });
        table.appendChild(tr);
      });

      container.appendChild(table);
    }




schedulesearchInput.addEventListener('input', function() {
  const filter = this.value.toLowerCase();
  
  // Get all tables
  const tables = document.querySelectorAll('#schedule table');
  
  tables.forEach(table => {
    const rows = table.querySelectorAll('tbody tr, tr'); // all rows
    
    let anyRowVisible = false; // check if table has any matching row
    
    rows.forEach((row, index) => {
      // Skip header row
      if (row.querySelectorAll('th').length > 0) return;
      
      const text = row.textContent.toLowerCase();
      if (text.includes(filter)) {
        row.style.display = '';
        anyRowVisible = true;
      } else {
        row.style.display = 'none';
      }
    });
    
    // Hide table if no rows match
    table.style.display = anyRowVisible ? '' : 'none';
    
    // Optional: hide table title (h3) if table hidden
    if (table.previousElementSibling && table.previousElementSibling.tagName === 'H3') {
      table.previousElementSibling.style.display = anyRowVisible ? '' : 'none';
    }
  });
});

            } catch (error) {
                console.error('Error loading schedule data:', error);
                alert('Failed to load schedule data. Please check the sheet ID and sharing settings.');
            }
        });

    </script>
</body>
</html>
